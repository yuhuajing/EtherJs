const {
    logger,
    sendTx,
    toU256Hex,
    payerAccount,
    formatEthAddress,
    toBuffer,
    checkTxResult,
    contractInterface,
    ETH_SENDER,
    faucet,
    calculateContractAddress,
    codeName,
    view,
    sleep,
    toEthAddress,
    hex2number,
} = require("./comm");
let { ethers } = require("ethers");
const { usdc_bytecode, usdt_bytecode, factory_bytecode, router_bytecode } = require("./const.json");

async function preDeploy() {
    const address = payerAccount.address;
    // Add initial test token generation for the first execution due to potential data clearance in the dev network
    for (let i = 0; i < 3; i++) {
        await faucet(address);
    }
    require("./deploy");
    await sleep(12); // We need this wait to depoly evm contract finish
}

async function start() {
    await preDeploy()
    const address = payerAccount.address;
    let sender = formatEthAddress(ETH_SENDER);
    let payload = {
        function: address + `::${codeName}::deploy`,
        type_arguments: [],
        arguments: [toBuffer(sender), toBuffer(usdc_bytecode)],
    };
    logger.info("movement: start deoply usdc token");
    let hash = await sendTx(payload);
    await checkTxResult(hash);
    let usdcAddress = await calculateContractAddress(sender);
    logger.info("movement: deployed usdc token address is %s", usdcAddress);

    logger.info("movement: start deoply usdt token");
    payload.arguments = [toBuffer(sender), toBuffer(usdt_bytecode)];
    hash = await sendTx(payload);
    await checkTxResult(hash);
    let usdtAddress = await calculateContractAddress(sender);
    logger.info("movement: deployed usdt token address is %s", usdtAddress);

    logger.info("movement: start deoply uniswap factory contract");
    payload.arguments = [
        toBuffer(sender),
        //  constructor(address _feeToSetter) public
        toBuffer(factory_bytecode + sender.slice(2)),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);
    let factoryAddress = await calculateContractAddress(sender);
    logger.info("movement: deployed factory address is %s", factoryAddress);
    logger.info("movement: start deoply uniswap router contract");
    payload.arguments = [
        toBuffer(sender),
        //  constructor(address _factory, address _WETH) public
        toBuffer(router_bytecode + factoryAddress.slice(2) + factoryAddress.slice(2)),
    ];

    hash = await sendTx(payload);
    await checkTxResult(hash);
    let routerAddress = await calculateContractAddress(sender);
    logger.info("movement: router address is %s", routerAddress);

    payload = {
        function: address + `::${codeName}::call`,
        type_arguments: [],
        arguments: [
            toBuffer(sender),
            toBuffer(factoryAddress),
            toBuffer(
                contractInterface.encodeFunctionData("createPair", [
                    toEthAddress(usdcAddress),
                    toEthAddress(usdtAddress),
                ])
            ),
        ],
    };
    hash = await sendTx(payload);
    await checkTxResult(hash);

    let calldata = contractInterface.encodeFunctionData("allPairsLength");
    let res = await view(factoryAddress, calldata);
    let len = ethers.toBigInt(res).toString();
    logger.info("movement: current pair count is %s", len);
    calldata = contractInterface.encodeFunctionData("allPairs", [parseInt(len) - 1]);
    res = await view(factoryAddress, calldata);
    let pairAddress = formatEthAddress("0x" + ethers.toBigInt(res).toString(16));
    logger.info("movement: create usdc and usdt pair address is %s", pairAddress);
    let info = {
        factoryAddress,
        usdcAddress,
        usdtAddress,
        pairAddress,
        routerAddress,
    };
    logger.success("movement: deploy contract result is", info);
    await swap(info);
}

async function swap(info) {
    let sender = formatEthAddress(ETH_SENDER);
    const address = payerAccount.address;
    let payload = {
        function: address + `::${codeName}::call`,
        type_arguments: [],
        arguments: [],
    };
    const balance_calldata = contractInterface.encodeFunctionData("balanceOf", [toEthAddress(sender)]);
    logger.info("movement:start mint 200 usdc to ", sender);
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.usdcAddress),
        toBuffer(
            contractInterface.encodeFunctionData("mint", [
                ETH_SENDER,
                // 200 * 1e18
                toU256Hex("200000000000000000000"),
            ])
        ),
    ];
    let hash = await sendTx(payload);
    await checkTxResult(hash);
    let balance = await view(info.usdcAddress, balance_calldata);
    logger.info("movement: %s current usdc balance is %s", sender, hex2number(balance));
    logger.info("movement:start mint 200 usdt to ", sender);
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.usdtAddress),
        toBuffer(
            contractInterface.encodeFunctionData("mint", [
                ETH_SENDER,
                // 200 * 1e18
                toU256Hex("200000000000000000000"),
            ])
        ),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);
    balance = await view(info.usdtAddress, balance_calldata);
    logger.info("movement:%s current usdt balance is %s", sender, hex2number(balance));

    logger.info("movement:approve 200 usdc token to router address ");
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.usdcAddress),
        toBuffer(
            contractInterface.encodeFunctionData("approve", [
                toEthAddress(info.routerAddress),
                // 200 * 1e18
                toU256Hex("200000000000000000000"),
            ])
        ),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);

    logger.info("movement:approve 200 usdt token to router address ");
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.usdtAddress),
        toBuffer(
            contractInterface.encodeFunctionData("approve", [
                toEthAddress(info.routerAddress),
                // 200 * 1e18
                toU256Hex("200000000000000000000"),
            ])
        ),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);

    logger.info("movement: add liquidity with 100 usdc and usdt token");
    const deadline = "2642382785";
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.routerAddress),
        toBuffer(
            contractInterface.encodeFunctionData("addLiquidity", [
                toEthAddress(info.usdtAddress),
                toEthAddress(info.usdcAddress),
                "100000000000000000000", // 100 * 1e18
                "100000000000000000000", // 100 * 1e18
                "0", //0
                "0", // 0
                toEthAddress(sender),
                deadline,
            ])
        ),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);
    balance = await view(info.usdcAddress, balance_calldata);
    logger.info("movement: %s current usdc balance is %s", sender, hex2number(balance));
    balance = await view(info.usdtAddress, balance_calldata);
    logger.info("movement: %s current usdc balance is %s", sender, hex2number(balance));

    logger.info("movement: swap 10 usdc for usdt token");
    payload.arguments = [
        toBuffer(sender),
        toBuffer(info.routerAddress),
        toBuffer(
            contractInterface.encodeFunctionData("swapExactTokensForTokens", [
                "10000000000000000000",
                "0",
                [toEthAddress(info.usdcAddress), toEthAddress(info.usdtAddress)],
                toEthAddress(sender),
                deadline,
            ])
        ),
    ];
    hash = await sendTx(payload);
    await checkTxResult(hash);

    balance = await view(info.usdcAddress, balance_calldata);
    logger.info("movement: %s current usdc balance is %s", sender, hex2number(balance));
    balance = await view(info.usdtAddress, balance_calldata);
    logger.info("movement: %s current usdc balance is %s", sender, hex2number(balance));
}

start();
