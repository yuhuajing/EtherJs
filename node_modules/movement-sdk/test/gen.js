const fs = require("fs");
const { exec } = require("child_process");
const { logger, sleep, contractFileName, contractName } = require("./comm");
const path = require("path");
const { ethers } = require("ethers");

async function start() {
    deleteFolderRecursive("yul");
    logger.info("movement: obtains runtime bytecode and deploy bytecode of the usdc from sol");
    let file = `./contracts/${contractFileName}.sol`;
    await runCmd(`solc --optimize --bin-runtime ${file} -o ./yul --overwrite`);
    let runtime = fs.readFileSync(`./yul/${contractName}.bin-runtime`).toString();
    await sleep(1);
    await runCmd(`solc --optimize --bin ${file} -o ./yul --overwrite`);
    await sleep(1);
    let bytecode = fs.readFileSync(`./yul/${contractName}.bin`).toString();
    let abiEncoder = ethers.AbiCoder.defaultAbiCoder();
    const params = abiEncoder.encode(["string", "string", "uint8"], ["USDC", "USDC", 18]);
    let construct_bytecode = bytecode + params.slice(2);
    logger.success(
        "movement: runtime bytecode length is %s, deploy bytecode length is %s ",
        runtime.length,
        construct_bytecode.length
    );
    deleteFolderRecursive("yul");
    fs.writeFileSync(`./yul/${contractName}.bin-runtime`, runtime);
    fs.writeFileSync(`./yul/${contractName}.bin`, construct_bytecode);
    return {
        runtime,
        bytecode: construct_bytecode,
    };
}
function deleteFolderRecursive(folderPath) {
    if (fs.existsSync(folderPath)) {
        fs.readdirSync(folderPath).forEach((file, index) => {
            const curPath = path.join(folderPath, file);
            if (fs.lstatSync(curPath).isDirectory()) {
                deleteFolderRecursive(curPath);
            } else {
                fs.unlinkSync(curPath);
            }
        });
    }
}

function runCmd(cmd) {
    return new Promise((resolve, reject) => {
        exec(cmd, (err, stdout, stderr) => {
            if (err) {
                console.log(err);
                reject(err);
                return;
            }
            resolve(stdout);
        });
    });
}
start();
